// --------------------------------------------------------------------------------------------------------------------
// <copyright file="AutoMapTests.cs" company="Epworth Consulting Ltd.">
//   © Epworth Consulting Ltd.
// </copyright>
// --------------------------------------------------------------------------------------------------------------------
namespace Atlas.Persistence.NHibernate.Tests.IntegrationTests
{
   using System;
   using System.Linq;
   using System.Linq.Expressions;
   using System.Xml.Linq;

   using Atlas.Core.Logging;
   using Atlas.Persistence;
   using Atlas.Persistence.NHibernate;
   using Atlas.Persistence.NHibernate.ByteCode.Castle;
   using Atlas.Persistence.NHibernate.Configuration;
   using Atlas.Persistence.NHibernate.Configuration.Fluent;
   using Atlas.Persistence.NHibernate.Configuration.Fluent.Conventions;
   using Atlas.Persistence.NHibernate.Implementations;
   using Atlas.Persistence.NHibernate.Testing;
   using Atlas.Persistence.NHibernate.Testing.Configuration;
   using Atlas.Persistence.NHibernate.Testing.Configuration.Fluent;
   using Atlas.Persistence.Testing.Entities;

   using global::NHibernate;

   using NUnit.Framework;

   // TODO: Need some SQL server tests too
   // TODO: Enumeration base types
   // TODO: Reference property interface vs class
   // TODO: StringLength and Required attribute types
   // TODO: Guid is generated by GuidComb

   // TODO: Ignores byte[] Version

   // TODO: Can attach entity that has byte[] Version

   // TODO: Automap Overrides

   // TODO: Reference property

   // TODO: IReference property

   public class AutoMapTests : SQLiteTestsBase
   {
      private AtlasAutoMappingConfiguration automappingConfiguration;
      private FluentAutoMapperConfigurer fluentMapperConfigurer;
      private INHibernatePersistenceConfiguration persistenceConfiguration;

      [SetUp]
      public void SetupBeforeEachTest()
      {
         this.automappingConfiguration = new SQLiteAtlasAutoMappingConfiguration();
         this.fluentMapperConfigurer = new FluentAutoMapperConfigurer();
         this.fluentMapperConfigurer.AutoMappingConfiguration(this.automappingConfiguration);

         this.persistenceConfiguration = new NHibernateConfiguration(new ConsoleLogger());
         this.persistenceConfiguration.RegisterConfigurer(new SQLiteDatabaseConfigurer());
         this.persistenceConfiguration.RegisterConfigurer(this.fluentMapperConfigurer);
         this.persistenceConfiguration.RegisterConfigurer(new ProxyConfigurer<CastleProxyFactoryFactory>());
      }

      [Test]
      public void SimpleEntityIsPersisted()
      {
         this.automappingConfiguration.ShouldMapType(c => c == typeof(Foo));
         this.fluentMapperConfigurer.AutoMapEntitiesFromAssemblyOf<Foo>();

         using (var unitOfWorkFactory = new SQLiteUnitOfWorkFactory(this.persistenceConfiguration, null, null, null, null, new ConsoleLogger()))
         {
            var entity = this.PersistEntity(unitOfWorkFactory, () => new Foo { StringValue = "myValue" });

            Assert.AreEqual(1, entity.ID);
         }
      }

      [Test]
      public void SimpleEntityCanBeReloaded()
      {
         this.automappingConfiguration.ShouldMapType(c => c == typeof(Foo));
         this.fluentMapperConfigurer.AutoMapEntitiesFromAssemblyOf<Foo>();

         using (var unitOfWorkFactory = new SQLiteUnitOfWorkFactory(this.persistenceConfiguration, null, null, null, null, new ConsoleLogger()))
         {
            var persistedEntity = this.PersistEntity(unitOfWorkFactory, () => new Foo { StringValue = "myValue" });

            var entity = this.LoadEntity<Foo>(unitOfWorkFactory, c => c.ID == persistedEntity.ID);

            Assert.AreEqual(persistedEntity.StringValue, entity.StringValue);
         }
      }

      [Test]
      public void SimpleEntityCanBeAttachedAndChanged()
      {
         this.automappingConfiguration.ShouldMapType(c => c == typeof(Foo));
         this.fluentMapperConfigurer.AutoMapEntitiesFromAssemblyOf<Foo>();

         using (var unitOfWorkFactory = new SQLiteUnitOfWorkFactory(this.persistenceConfiguration, null, null, null, null, new ConsoleLogger()))
         {
            var persistedEntity = this.PersistEntity(unitOfWorkFactory, () => new Foo { StringValue = "myValue" });

            using (var unitOfWork = unitOfWorkFactory.Create())
            {
               unitOfWork.Attach(persistedEntity);

               persistedEntity.StringValue = "newStringValue";
               unitOfWork.Save();
            }
         }
      }

      [Test]
      [ExpectedException(typeof(MappingException))]
      public void ExceptionThrownWhenTryingToPersistEntityNotAutoMapped()
      {
         this.automappingConfiguration.ShouldMapType(c => false);
         this.fluentMapperConfigurer.AutoMapEntitiesFromAssemblyOf<Foo>();

         using (var unitOfWorkFactory = new SQLiteUnitOfWorkFactory(this.persistenceConfiguration, null, null, null, null, new ConsoleLogger()))
         {
            this.PersistEntity(unitOfWorkFactory, () => new Foo { StringValue = "myValue" });
         }
      }

      [Test]
      public void OptimisticLockingEntityIsPersistedWithCorrectAutoMappingConfiguration()
      {
         this.automappingConfiguration.ShouldMapType(c => c == typeof(Optimistic));
         this.fluentMapperConfigurer.AutoMapEntitiesFromAssemblyOf<Optimistic>();

         using (var unitOfWorkFactory = new SQLiteUnitOfWorkFactory(this.persistenceConfiguration, null, null, null, null, new ConsoleLogger()))
         {
            var entity = this.PersistEntity(unitOfWorkFactory, () => new Optimistic { StringValue = "myValue" });

            Assert.AreEqual(1, entity.ID);
         }
      }

      [Test]
      [ExpectedException(typeof(PropertyValueException))]
      public void ExceptionThrownWhenTryingToPersistOptimisticLockingEntityWithIncorrectAutoMappingConfiguration()
      {
         var myAutomappingConfiguration = new AtlasAutoMappingConfiguration();
         myAutomappingConfiguration.ShouldMapType(c => c == typeof(Optimistic));

         this.fluentMapperConfigurer.AutoMappingConfiguration(myAutomappingConfiguration);
         this.fluentMapperConfigurer.AutoMapEntitiesFromAssemblyOf<Optimistic>();

         using (var unitOfWorkFactory = new SQLiteUnitOfWorkFactory(this.persistenceConfiguration, null, null, null, null, new ConsoleLogger()))
         {
            this.PersistEntity(unitOfWorkFactory, () => new Optimistic { StringValue = "myValue" });
         }
      }

      [Test]
      public void OptimisticLockingEntityCanBeReloaded()
      {
         this.automappingConfiguration.ShouldMapType(c => c == typeof(Optimistic));
         this.fluentMapperConfigurer.AutoMapEntitiesFromAssemblyOf<Optimistic>();

         using (var unitOfWorkFactory = new SQLiteUnitOfWorkFactory(this.persistenceConfiguration, null, null, null, null, new ConsoleLogger()))
         {
            var persistedEntity = this.PersistEntity(unitOfWorkFactory, () => new Optimistic { StringValue = "myValue" });

            var entity = this.LoadEntity<Optimistic>(unitOfWorkFactory, c => c.ID == persistedEntity.ID);

            Assert.AreEqual(persistedEntity.StringValue, entity.StringValue);
         }
      }

      [Test]
      public void OptimisticLockingEntityCanBeAttachedAndChanged()
      {
         this.automappingConfiguration.ShouldMapType(c => c == typeof(Optimistic));
         this.fluentMapperConfigurer.AutoMapEntitiesFromAssemblyOf<Optimistic>();

         using (var unitOfWorkFactory = new SQLiteUnitOfWorkFactory(this.persistenceConfiguration, null, null, null, null, new ConsoleLogger()))
         {
            var persistedEntity = this.PersistEntity(unitOfWorkFactory, () => new Optimistic { StringValue = "myValue" });

            using (var unitOfWork = unitOfWorkFactory.Create())
            {
               unitOfWork.Attach(persistedEntity);

               persistedEntity.StringValue = "newStringValue";
               unitOfWork.Save();
            }
         }
      }

      [Test]
      public void GuidKeyEntityIsPersisted()
      {
         this.automappingConfiguration.ShouldMapType(c => c == typeof(GuidParent));
         this.fluentMapperConfigurer.AutoMapEntitiesFromAssemblyOf<GuidParent>();
         this.fluentMapperConfigurer.RegisterOverride<GuidParent>(c => c.Id(p => p.Guid));

         using (var unitOfWorkFactory = new SQLiteUnitOfWorkFactory(this.persistenceConfiguration, null, null, null, null, new ConsoleLogger()))
         {
            var parent = this.PersistEntity(unitOfWorkFactory, () => new GuidParent { Name = "myName" });

            Assert.IsTrue(parent.Guid != Guid.Empty);
         }
      }

      [Test]
      public void ParentAndChildEntitiesArePersisted()
      {
         this.automappingConfiguration.ShouldMapType(c => c == typeof(GuidParent) || c == typeof(GuidChild));
         this.fluentMapperConfigurer.AutoMapEntitiesFromAssemblyOf<GuidParent>();
         this.fluentMapperConfigurer.RegisterOverride<GuidParent>(c => c.Id(p => p.Guid));
         this.fluentMapperConfigurer.RegisterOverride<GuidChild>(c => c.Id(p => p.Guid));

         using (var unitOfWorkFactory = new SQLiteUnitOfWorkFactory(this.persistenceConfiguration, null, null, null, null, new ConsoleLogger()))
         {
            var parent = this.PersistEntity(unitOfWorkFactory, () => new GuidParent { Name = "myName" });

            var child = this.PersistEntity(unitOfWorkFactory, () => new GuidChild { GuidParent = parent });

            Assert.IsTrue(child.Guid != Guid.Empty);
         }
      }

      [Ignore] // Not yet fully implemented
      [Test]
      public void XElementPropertyIsPersisted()
      {
         this.automappingConfiguration.ShouldMapType(c => c == typeof(XmlProperty));
         this.fluentMapperConfigurer.AutoMapEntitiesFromAssemblyOf<XmlProperty>();

         this.fluentMapperConfigurer.RegisterConvention<XElementConvention>();

         using (var unitOfWorkFactory = new SQLiteUnitOfWorkFactory(this.persistenceConfiguration, null, null, null, null, new ConsoleLogger()))
         {
            this.PersistEntity(unitOfWorkFactory, () => new XmlProperty { Xml = XElement.Parse("<xml/>") });
         }
      }

      private TEntity PersistEntity<TEntity>(IUnitOfWorkFactory unitOfWorkFactory, Func<TEntity> createEntityFunc) where TEntity : class
      {
         using (var unitOfWork = unitOfWorkFactory.Create())
         {
            var entity = createEntityFunc();
            unitOfWork.Add(entity);
            unitOfWork.Save();

            return entity;
         }
      }

      private TEntity LoadEntity<TEntity>(IUnitOfWorkFactory unitOfWorkFactory, Expression<Func<TEntity, bool>> predicate) where TEntity : class
      {
         using (var unitOfWork = unitOfWorkFactory.Create())
         {
            return unitOfWork.Query<TEntity>().Single(predicate);
         }
      }
   }
}
